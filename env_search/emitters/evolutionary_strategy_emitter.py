import gin
import ribs
import numpy as np
from ribs._utils import validate_batch_args

@gin.configurable
class EvolutionStrategyEmitter(ribs.emitters.EvolutionStrategyEmitter):
    """gin-configurable version of pyribs EvolutionStrategyEmitter.
    Also implements some Darwinian bound handling approaches, described in this
    paper: https://www.sciencedirect.com/science/article/pii/S2210650219301622

    """

    def ask(self):
        # Return addition None to cope with parent sol API of
        # MapElitesBaselineWarehouseEmitter
        return super().ask(), None


    def tell(self,
             solution_batch,
             objective_batch,
             measures_batch,
             status_batch,
             value_batch,
             metadata_batch=None):
        """Gives the emitter results from evaluating solutions.

        The solutions are ranked based on the `rank()` function defined by
        `self._ranker`. Then, the ranked solutions are passed to CMA-ES for
        adaptation.

        This function also checks for restart condition and restarts CMA-ES
        when needed.

        Args:
            solution_batch (array-like): (batch_size, :attr:`solution_dim`)
                array of solutions generated by this emitter's :meth:`ask()`
                method.
            objective_batch (array-like): 1D array containing the objective
                function value of each solution.
            measures_batch (array-like): (batch_size, measure space
                dimension) array with the measure space coordinates of each
                solution.
            status_batch (array-like): 1D array of
                :class:`ribs.archive.AddStatus` returned by a series of calls
                to archive's :meth:`add()` method.
            value_batch (array-like): 1D array of floats returned by a series
                of calls to archive's :meth:`add()` method. For what these
                floats represent, refer to :meth:`ribs.archives.add()`.
            metadata_batch (array-like): 1D object array containing a metadata
                object for each solution.
        """
        # Preprocessing arguments.
        solution_batch = np.asarray(solution_batch)
        objective_batch = np.asarray(objective_batch)
        measures_batch = np.asarray(measures_batch)
        status_batch = np.asarray(status_batch)
        value_batch = np.asarray(value_batch)
        batch_size = solution_batch.shape[0]
        metadata_batch = (np.empty(batch_size, dtype=object) if
                          metadata_batch is None else np.asarray(metadata_batch,
                                                                 dtype=object))

        # Validate arguments.
        validate_batch_args(archive=self.archive,
                            solution_batch=solution_batch,
                            objective_batch=objective_batch,
                            measures_batch=measures_batch,
                            status_batch=status_batch,
                            value_batch=value_batch,
                            metadata_batch=metadata_batch)

        # Increase iteration counter.
        self._itrs += 1

        # Count number of new solutions.
        new_sols = status_batch.astype(bool).sum()

        # Sort the solutions using ranker.
        indices, ranking_values = self._ranker.rank(
            self, self.archive, self._rng, solution_batch, objective_batch,
            measures_batch, status_batch, value_batch, metadata_batch)

        # Select the number of parents.
        num_parents = (new_sols if self._selection_rule == "filter" else
                       self._batch_size // 2)

        # If the number of successful evaluation is smaller than `num_parents`,
        # use the number of successful ones.
        num_parents = np.min([num_parents, new_sols])

        # Update Evolution Strategy.
        self._opt.tell(indices, num_parents)

        # Check for reset.
        if (self._opt.check_stop(ranking_values[indices]) or
                self._check_restart(new_sols)):
            new_x0 = self.archive.sample_elites(1).solution_batch[0]
            self._opt.reset(new_x0)
            self._ranker.reset(self, self.archive, self._rng)
            self._restarts += 1
